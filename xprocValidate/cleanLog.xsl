<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns:c="http://www.w3.org/ns/xproc-step"
    version="2.0" exclude-result-prefixes="xs c">
    
    <!-- 
    IF the xml error file has not already gone through a cleaning process (e.g. dropping the particular id value of id not found to enable better reporting)
    then do that cleaning 
    otherwise we can force re  cleaning (if logic has changed) when we merge the file 
    thus the XSLT should work on both original and post processed log file formats-->
    
    <xsl:param name="gpForceReClean" select="'false'" as="xs:string"/>
    <xsl:param name="gpDataBasePath" select="'file:/C:/Users/colin/Documents/newco/TSO/TNA'" as="xs:string?"/>
    <xsl:param name="gpLogInfoFilename" as="xs:string?"/>
    
    <xsl:output method="xml" indent="yes"/>
    
    <xsl:variable name="gvForceReClean" select="$gpForceReClean='true'" as="xs:boolean"/>
    
    <xsl:variable name="gvValueMatchPattern" as="xs:string">(The value |Value )'([^']*)' (.*)$</xsl:variable>
    <xsl:variable name="gvDoubleHashMatchPattern" as="xs:string">(^'.+#.+#.+') is not a valid value for 'anyURI'.$</xsl:variable>
    <xsl:variable name="gvDuplicateMatchPattern" as="xs:string">(^Duplicate unique value )(.*)(declared.*)</xsl:variable>
    <xsl:variable name="gvIDREFPattern" as="xs:string">(^There is no ID/IDREF binding for IDREF)(.*)</xsl:variable>
    <xsl:variable name="gvKeyRefPattern" as="xs:string">(^Key )(.* with value .*)('.*')( not found.*$)</xsl:variable>
    <xsl:variable name="gvNCPattern" as="xs:string">^'.* is not a valid value for 'NCName'.$</xsl:variable>
    <xsl:variable name="gvYearPattern" as="xs:string">^'' is not a valid value for 'gYear'.$</xsl:variable>
    <xsl:variable name="gvIntPattern" as="xs:string">^'' is not a valid value for 'integer'.$</xsl:variable>
    <xsl:variable name="gvDocTypePattern" as="xs:string">^Value '' is not facet-valid with respect to enumeration '\[EnglandAct, GreatBritainAct.+</xsl:variable>
    
    <xsl:output method="xml" indent="yes"/>
    
    <xsl:template match="c:errors">
        <fileLog logInfoFilename="{$gpLogInfoFilename}">
            <xsl:apply-templates/>
        </fileLog>
    </xsl:template>
    
    <xsl:template match="c:error | error[$gvForceReClean or not(cleanedText)]" priority="+1">
        <xsl:variable name="vXmlFilename" select="xs:string(base-uri(.))" as="xs:string"/>
        <xsl:variable name="vElementName" select="local-name(.)" as="xs:string"/>
        <xsl:variable name="vLine" select="@line" as="xs:string?"/>
        <xsl:variable name="vColumn" select="@column" as="xs:string?"/>
        <xsl:variable name="vText" select="." as="xs:string?"/>
        
        <xsl:choose>
            <!-- this is being run on the error information generated by XProc
                so drop any duplicate errors for same issue being produced by that process -->
            <xsl:when test="self::c:error and not(preceding-sibling::c:error[(@line=$vLine) and (@column=$vColumn) and (.=$vText)])">
                <xsl:variable name="vCleanText">
                    <!-- input varies when running from bat file or within oxygen (default validaor may be different
                        so need logic below and we should use filename passed in from XProc
                    
                    Bat file  <input>org.xml.sax.SAXParseException; systemId: file:/C:/Users/colin/Documents/newco/TSO/TNA/data27-02-2020/enacted/other/anaw/2012/anaw-2012-1-enacted-data.xml; lineNumber: 23; columnNumber: 41; cvc-attribute.3: The value 'primarys' of attribute 'Value' on element 'ukm:DocumentCategory' is not valid with respect to its type, 'null'.</input>
                    <input>ValidationException: Value "primarys" contravenes the enumeration facet "euretained, secondary, primary" of the type of attribute Value</input>
                    Oxygen -->
                    <xsl:choose>
                        <xsl:when test="starts-with(.,'org.xml.sax.SAXParseException;')">
                            <xsl:value-of select="replace(.,'^org.xml.sax.SAXParseException; systemId: ','')"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="."/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                 <xsl:variable name="vXmlFilename" as="xs:string?">
                     <xsl:choose>
                         <xsl:when test="contains($vXmlFilename,$gpDataBasePath)">
                             <xsl:value-of select="substring-after($vXmlFilename,concat($gpDataBasePath,'/'))"/>
                         </xsl:when>
                         <xsl:otherwise>
                             <xsl:value-of select="$vXmlFilename"/>
                         </xsl:otherwise>
                     </xsl:choose>
                 </xsl:variable>
                
                <xsl:variable name="vCleanText" select="replace($vCleanText,'.+;.+;.+;','')" as="xs:string?"/>
                <xsl:variable name="vErrorType" select="replace($vCleanText,':.+','')"/>
                <xsl:variable name="vCleanText" select="normalize-space(replace($vCleanText,'^[^:]+:',''))" as="xs:string?"/>
                <xsl:call-template name="makeCleanError">
                    <xsl:with-param name="pXmlFilename" select="$vXmlFilename"/>
                    <xsl:with-param name="pOriginalText" select="$vCleanText"/>
                    <xsl:with-param name="pCleanText" select="$vCleanText"/>
                    <xsl:with-param name="pErrorType" select="$vErrorType"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="self::error">
                <xsl:call-template name="makeCleanError"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    
    <!-- create the output element having dropped the sax exception message,
        having extracted the line numbers and filename and errortype ready to be put in attributes
        and then we put  a version of the text that makes it easier to report on in the cleanedText element -->
    <xsl:template name="makeCleanError">
        <xsl:param name="pXmlFilename" select="@xmlFilename" as="xs:string"/>
        <xsl:param name="pErrorType" select="@errorType" as="xs:string"/>
        <xsl:param name="pCleanText" select="originalText" as="xs:string"/>
        <xsl:param name="pOriginalText" select="originalText" as="xs:string"/>
        <!-- dont create the error element if this error is just another way of reporting the same error as will have been reported on the line before -->
        <!-- these errors do not give good detail but are followed by a different error that does
            drop
      'term-the-help-to-buy:-isa-scheme' is not a valid value for 'NCName'.
        keep
The value 'term-the-help-to-buy:-isa-scheme' of attribute 'id' on element 'Term' is not valid with respect to its type, 'NCName'.      
        -->    
        <!-- no point reporting on '' is not a valid value for 'gYear'.
            as the next error 
            The value of attribute 'Year' on element 'ukm:Correction' is not valid with respect to its type, 'gYear'.
            Is the same issue.
            Same for integer for @Number
        -->
        <xsl:if test="not(matches($pCleanText,$gvDocTypePattern) or matches($pCleanText,$gvNCPattern) or matches($pCleanText,$gvYearPattern) or matches($pCleanText,$gvIntPattern))">
            <xsl:element name="error">
                <xsl:copy-of select="@line,@column"/>
                <xsl:attribute name="xmlFilename" select="normalize-space($pXmlFilename)"/>
                <xsl:attribute name="errorType" select="normalize-space($pErrorType)"/>
                <!--<input><xsl:value-of select="."/></input>-->
                <originalText>
                    <xsl:value-of select="$pOriginalText"/>
                </originalText>
                <cleanedText>
                    <xsl:choose>
                        <xsl:when test="matches($pCleanText,$gvValueMatchPattern)">
                            <!-- get rid of the value in between the single quotes as it just multiplies the same base error -->
                            <xsl:analyze-string select="$pCleanText" regex="{$gvValueMatchPattern}">
                               <xsl:matching-substring>
                                    <xsl:value-of select="normalize-space(regex-group(1))"/>
                                    <xsl:text> </xsl:text>
                                    <xsl:value-of select="normalize-space(regex-group(3))"/>
                               </xsl:matching-substring>
                                <xsl:non-matching-substring>
                                     <xsl:value-of select="$pCleanText"/>
                                </xsl:non-matching-substring>
                            </xsl:analyze-string>
                        </xsl:when>
                        <xsl:when test="matches($pCleanText,$gvDoubleHashMatchPattern)">
                            <!-- get rid of the URI when its a double hash issue
                                'http://www.justice.gov.uk/guidance/courts-and-tribunals/courts/procedure-rules/civil/contents/parts/part44.htm#IDAYR0HC#IDAYR0HC' is not a valid value for 'anyURI'.
                            -->
                            <xsl:text>Double hash URI like URI#xxx#xxx is not a valid value for 'anyURI'.</xsl:text>
                        </xsl:when>
                        <xsl:when test="matches($pCleanText,$gvDuplicateMatchPattern)">
                            <!-- get rid of the value from the Duplicate unique error
                            Duplicate unique value [cc00055] declared for identity constraint of element "Legislation".
                            -->
                            <xsl:analyze-string select="$pCleanText" regex="{$gvDuplicateMatchPattern}">
                               <xsl:matching-substring>
                                    <xsl:value-of select="normalize-space(regex-group(1))"/>
                                    <xsl:text> </xsl:text>
                                    <xsl:value-of select="normalize-space(regex-group(3))"/>
                               </xsl:matching-substring>
                                <xsl:non-matching-substring>
                                     <xsl:value-of select="$pCleanText"/>
                                </xsl:non-matching-substring>
                            </xsl:analyze-string>
                        </xsl:when>
                        <xsl:when test="matches($pCleanText,$gvIDREFPattern)">
                            <!-- get rid of the value from the Duplicate unique error
                            Duplicate unique value [cc00055] declared for identity constraint of element "Legislation".
                            -->
                            <xsl:analyze-string select="$pCleanText" regex="{$gvIDREFPattern}">
                               <xsl:matching-substring>
                                    <xsl:value-of select="normalize-space(regex-group(1))"/>
                               </xsl:matching-substring>
                                <xsl:non-matching-substring>
                                     <xsl:value-of select="$pCleanText"/>
                                </xsl:non-matching-substring>
                            </xsl:analyze-string>
                        </xsl:when>
                        <xsl:when test="matches($pCleanText,$gvKeyRefPattern)">
                            <!-- get rid of the value from the Duplicate unique error
                            Key 'refCrossrefToCommentary' with value 'key-635a394e89ac04e3ba7725750fe50c68' not found for identity constraint of element 'Legislation'.
                            -->
                            <xsl:analyze-string select="$pCleanText" regex="{$gvKeyRefPattern}">
                               <xsl:matching-substring>
                                    <xsl:value-of select="normalize-space(regex-group(1))"/>
                                    <xsl:text> </xsl:text>
                                    <xsl:value-of select="normalize-space(regex-group(2))"/>
                                    <xsl:text> </xsl:text>
                                    <xsl:value-of select="normalize-space(regex-group(4))"/>
                               </xsl:matching-substring>
                                <xsl:non-matching-substring>
                                     <xsl:value-of select="$pCleanText"/>
                                </xsl:non-matching-substring>
                            </xsl:analyze-string>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$pCleanText"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </cleanedText>
            </xsl:element>
        </xsl:if>
    </xsl:template>
    
    <!-- pass through everything else -->
    <xsl:template match="*|@*|processing-instruction()|text()" priority="-1">
        <xsl:copy>
            <xsl:apply-templates select="*|@*|processing-instruction()|text()"/>
        </xsl:copy>
    </xsl:template>
</xsl:stylesheet>